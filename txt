import { File, Projeto } from '../interfaces'
import { EntityResult } from '../interfaces/entity-result'
import { RepositorioVerificacao } from '../interfaces/repositorio-verificacao'
import { dataInicioMaiorFinal } from '../utils/dateUtil'
import http from './http'

interface FetchParams {
  page: number
  itemsPerPage: number
  sortBy: { key: string; order: 'asc' | 'desc' }[]
  search?: string,
  tipo: string
}

export const repositorioVerificacaoService = {
  // Endpoint homologacao

  async update(rule_id: string, updated_rule: RepositorioVerificacao): Promise<EntityResult<RepositorioVerificacao>> {
    const result = await http.put<EntityResult<RepositorioVerificacao>>(`/rules/lista_cargas/instructions/${rule_id}`, updated_rule);
    return result.data;
  },

  async getAll(): Promise<EntityResult<RepositorioVerificacao[]>> {
    const { data } = await http.get('/rules/lista_cargas/instructions')
    return data
  },

  async getOriginalRuleById(rule_id: string): Promise<EntityResult<RepositorioVerificacao>> {
    const { data } = await http.get(`/verifications/original/${rule_id}`);
    return data;
  },

  // Endpoints Mockup
  async getAllMockup(): Promise<RepositorioVerificacao[]> {
    const { data } = await http.get('/repositorio-verificacao')
    return data
  },

  async getByTipo(tipo: string): Promise<RepositorioVerificacao[]> {
    const { data } = await http.get('/repositorio-verificacao')
    return data.filter(x => x.tipo === tipo);
  },

  async buscarPorId(id: number): Promise<File> {
    const { data } = await http.get(`/projetos/${id}`)
    return data
  },

  async buscarPorDataTipoDocumento(dataInicio: string, dataFim: string, tipoDocumento: string): Promise<Projeto[]> {
    try {
      let { data } = await http.get('/projetos');



      data = data.filter((x: {data: string}) => x.data >= dataInicio && x.data <= dataFim);
      return data;      
    } catch (error) {
      throw error;
    }
  },

  async criar(projeto: Projeto): Promise<Projeto> {
    const { data } = await http.post('/projetos', projeto)
    return data
  },

  async atualizar(arquivo: File): Promise<File> {
    const { data } = await http.put(`/projetos/${arquivo.id}`, arquivo)
    return data
  },

  async deletar(id: number): Promise<void> {
    await http.delete(`/projetos/${id}`)
  },

  async getSeverSide({ page, itemsPerPage, sortBy, search, tipo }: FetchParams) {
    return new Promise(async (resolve, reject) => {
      try {
        await new Promise(resolve => setTimeout(resolve, 400));
        let filtered = await this.getByTipo(tipo);

        if (search) {
          filtered = filtered.filter((file) => 
            file?.id?.toLowerCase().includes(search.toLowerCase())
            || file?.texto?.toLowerCase().includes(search.toLowerCase())
            || file?.documentoFonte?.toLowerCase().includes(search.toLowerCase())
        )
        }

        if (sortBy.length) {
          const { key, order } = sortBy[0]
          filtered.sort((a, b) => { 
            const aVal = a[key] 
            const bVal = b[key]
            if (typeof aVal === 'string') {
              return order === 'asc' ? aVal?.localeCompare(bVal) : bVal?.localeCompare(aVal)
            } else {
              return order === 'asc' ? aVal - bVal : bVal - aVal
            }
          })
        }

        const start = (page - 1) * itemsPerPage
        const end = start + itemsPerPage
        const paginated = filtered.slice(start, end)

        resolve({ items: paginated, total: filtered.length })
      } catch (error) {
        console.log(error);
        return reject(error);
      }
    })
  },

}

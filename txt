import { defineStore } from "pinia";
import { ref, nextTick, computed } from "vue";
import { jobService } from "../api/jobService";
import { hasValue, sleep } from "../utils/util";
import { JobFile } from "../interfaces/fiscalizacaoModels/job-file";

export const useJobPollingStore = defineStore("jobPolling", () => {

  const isPollingActive = ref(false);
  const statusFile = ref("");
  const stageFile = ref("");
  const jobIdRuntime = ref("");
  const relatorioFinalizado = ref(false);
  const isGerandoAnalise = ref(false);
  const isFailed = ref(false);
  const currentJobFiles = ref<JobFile[]>([]);

  let onCompleteCallback: ((jobId: string, currentJobFiles: JobFile[]) => void) | null = null;
  let onErrorCallback: ((message: string, currentJobFiles: JobFile[]) => void) | null = null;

  async function start(jobId: string, savedJobFiles: JobFile[]) {
    try {
      if (isPollingActive.value) return;
      isPollingActive.value = false;
      await nextTick();

      isFailed.value = false;
      isGerandoAnalise.value = true;
      isPollingActive.value = true;
  
      let finished = false;
      let errorCount = 0;
  
      while (isPollingActive.value && !finished) {
        const result = await jobService.getJobById(jobId);
  
        if (!result.success) {
          isFailed.value = true;
          stop();
          onErrorCallback?.(result.message ?? "Erro ao consultar job.", savedJobFiles);
          return;
        }
  
        statusFile.value = result.model.status;
        stageFile.value = result.model.stage;
  
        if (statusFile.value === "completed" && stageFile.value === "done") {
          finished = true;
          onCompleteCallback?.(jobId, savedJobFiles);
          relatorioFinalizado.value = true;
          isGerandoAnalise.value = false;
          jobIdRuntime.value = jobId;
          localStorage.removeItem("currentJobId");
          stop();
          break;
        }
  
        if (statusFile.value === "failed" || stageFile.value === "error") {
          errorCount++;
          if (errorCount >= 3) {
            isFailed.value = true;
            localStorage.removeItem("currentJobId");
            stop();
            onErrorCallback?.(result.message ?? "A job falhou.", savedJobFiles);
            return;
          }
        }
  
        for (let i = 0; i < 20; i++) {
          if (!isPollingActive.value) return;
          await sleep(1000);
        }
      }      
    } catch (error) {
      isFailed.value = true;
      localStorage.removeItem("currentJobId");
      statusFile.value = "failed"
      stageFile.value = "error"
      stop();
      onErrorCallback?.("A job falhou.", savedJobFiles);
      return;
    }
  }

  function stop() {
    currentJobFiles.value = [];    
    relatorioFinalizado.value = true;
    isPollingActive.value = false;
    isGerandoAnalise.value = false;
  }

  async function onComplete(callback: (jobId: string, savedJobFiles: JobFile[]) => void) {
    onCompleteCallback = callback;
  }

  function onError(callback: (message: string, savedJobFiles: JobFile[]) => void) {
    onErrorCallback = callback;
  }

  function loadCurrentJobFiles(currentJobFilesGotten?: string): JobFile[] {
    const savedJobFiles = hasValue(localStorage.getItem("currentJobFiles")) ? localStorage.getItem("currentJobFiles") : currentJobFilesGotten;
    if (savedJobFiles) {
      currentJobFiles.value = JSON.parse(savedJobFiles);
    }

    return currentJobFiles.value;
  }

  return {
    start,
    stop,
    statusFile,
    stageFile,
    relatorioFinalizado,
    isGerandoAnalise,
    jobIdRuntime,
    isPollingActive,
    onComplete,
    onError,
    isFailed,
    loadCurrentJobFiles,
  };
});

# app/jobs.py
from __future__ import annotations
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
import json
import threading
from typing import Optional

from .config import JOBS_DIR

_lock = threading.Lock()

@dataclass
class Job:
    job_id: str
    status: str     
    stage: str       
    message: Optional[str]
    created_at: str
    updated_at: str
    original_filename: str

    @property
    def job_dir(self) -> Path:
        return JOBS_DIR / self.job_id

    @property
    def report_dir(self) -> Path:
        return self.job_dir / "verification_reports"

    @property
    def report_file(self) -> Optional[Path]:
        if not self.report_dir.exists():
            return None
        files = list(self.report_dir.glob("*"))
        return files[0] if files else None


_jobs_memory: dict[str, Job] = {}


def _job_meta_path(job_id: str) -> Path:
    return JOBS_DIR / job_id / "job_meta.json"


def create_job(job_id: str, original_filename: str) -> Job:
    now = datetime.utcnow().isoformat()
    job = Job(
        job_id=job_id,
        status="queued",
        stage="pending",
        message=None,
        created_at=now,
        updated_at=now,
        original_filename=original_filename,
    )

    with _lock:
        _jobs_memory[job_id] = job
        job.job_dir.mkdir(parents=True, exist_ok=True)
        save_job(job)

    return job


def save_job(job: Job) -> None:
    meta_path = _job_meta_path(job.job_id)
    meta_path.parent.mkdir(parents=True, exist_ok=True)
    with meta_path.open("w", encoding="utf-8") as f:
        json.dump(asdict(job), f, indent=2)


def load_job(job_id: str) -> Optional[Job]:
    with _lock:
        if job_id in _jobs_memory:
            return _jobs_memory[job_id]

    meta_path = _job_meta_path(job_id)
    if not meta_path.exists():
        return None

    with meta_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    job = Job(**data)
    with _lock:
        _jobs_memory[job_id] = job
    return job


def update_job(job_id: str, *, status: Optional[str] = None,
               stage: Optional[str] = None,
               message: Optional[str] = None) -> Job:
    job = load_job(job_id)
    if job is None:
        raise KeyError(f"Job {job_id} not found")

    if status is not None:
        job.status = status
    if stage is not None:
        job.stage = stage
    if message is not None:
        job.message = message

    job.updated_at = datetime.utcnow().isoformat()
    with _lock:
        _jobs_memory[job_id] = job
        save_job(job)

    return job
